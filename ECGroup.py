
import math
import random
import matplotlib.pyplot as plt
from ECGroupClasses import ECGroup, Point

def gcd(x: int,y: int) -> int:
    d = 1
    test_d = 2
    while test_d < x and test_d < y:
        if x % test_d == 0 and y % test_d == 0:
            d = test_d

        test_d += 1
    return d

def solve_mod_z(p: int, g: int, h: int) -> int:
    d = gcd(p,g)
    if (h % d) != 0:
        return None

    g = int(g/d)
    h = int(h/d)
    p = int(p/d)
    try:
        g_inv = pow(g, -1, p)
    except:
        print(f"g: {g} p: {p}")
    return h*g_inv % p

def visual(ec, P = None):
    if P is None:
        P = ec.points[1]
    Q = Point(math.inf, math.inf)

    points_visited = []
    xs, ys = [], []

    while Q not in points_visited:
        points_visited.append(Q)
        if not math.isinf(Q.x):
            xs.append(Q.x)
            ys.append(Q.y)
        Q = ec.add(Q, P)

    plt.figure()

    # Plot the path
    plt.scatter(xs, ys)

    # Draw arrows to indicate direction
    for i in range(len(xs) - 1):
        dx = xs[i+1] - xs[i]
        dy = ys[i+1] - ys[i]
        plt.quiver(xs[i], ys[i], dx, dy,
                   angles='xy', scale_units='xy', scale=1,
                   width=0.003)

    # Highlight generator P
    plt.scatter(P.x, P.y, color='red', zorder=3)
    plt.scatter(xs[-1], ys[-1], color='green', zorder=3)

    # Axis scaling
    pad = 0
    plt.xlim(0, ec.p - 1)
    plt.ylim(0, ec.p - 1)
    plt.gca().set_aspect('equal', adjustable='box')

    plt.grid(True)
    plt.title(f"Cyclic Subgroup Generated by P: a: {ec.a} | b: {ec.b} | p: {ec.p}")
    plt.show()

def find_a_and_b_for_prime_p(p: int) -> list[ECGroup]:
    ecgroups = []
    if p < 5:
        return ecgroups

    for a in range(60,p):
        for b in range(60,p):
            if ((4 * a**3 + 27 * b**2) % p != 0):
                possible_group = ECGroup(a,b,p)
                if ECGroup.is_prime(len(possible_group.points)) and len(possible_group.points) >= 5:
                    ecgroups.append(possible_group)
                    print(f"a: {a} | b: {b} | p: {p} | Order: {len(possible_group.points)}")

    print()
    return ecgroups

def work_with_ecgroup(ecgroup: ECGroup):
    zp = len(ecgroup.points)
    p = ecgroup.p
    ecgroup.isomorphism() 

    G = random.choice(ecgroup.generators)
    g = G.order  

    H = Point(math.inf, math.inf)
    while H == Point(math.inf, math.inf) or H == G:
        H = random.choice(ecgroup.points)
    h = H.order
    
    k = solve_mod_z(zp, g, h)

    print(f"E(Z_{p}) ~ Z_{zp}")
    print(f"Generator G ~ g: {G} ~ {g} | Target H ~ h: {H} ~ {h} | Solution k: {k}")
    print(f"Verification of kG = H: ")
    print(f"    {k}*{G} = {ecgroup.multiply(G, k)} = {H}")
    print(f"    {k}*{g} mod {zp} = {(k*g)%zp} mod {zp} = {h%zp} mod {p}")

    if (k*g) % zp != h % zp:
        print(f"ERROR: {(k*g)%zp} mod {zp} != {h} mod {zp}")
    if not(ecgroup.multiply(G, k) == H):
        print(f"ERROR: {k*G} != {H}")

    print()
    visual(ecgroup, G)

def prime_order_ecgroups_for_prime_p(p = 7):
    ecgroups = find_a_and_b_for_prime_p(p)
    for group in ecgroups:
        work_with_ecgroup(group)

def main():
    if False:
        find_a_and_b_for_prime_p(7)

    p = 107
    a = 11
    b = 13

    ecgroup = ECGroup(a,b,p)
    example_ecgroup = ECGroup(3,3,7)
    #work_with_ecgroup(ecgroup)
    #work_with_ecgroup(example_ecgroup)
    #prime_order_ecgroups_for_prime_p(107)

    work_with_ecgroup(ECGroup(4,8,11))
    
if __name__ == "__main__":
    main()